---
data: "2019-10-24"
publishdate: "2019-10-24"
lastmod: "2019-10-24"
draft: false
title: "AcWing787题 ——归并排序（Merge sort）"
tags: ["归并排序","C++","AcWing"]
series: ["算法练习生"]
categories: ["算法"]
toc: true
summary: "算法日记2————归并排序"
---

## 题目

给定你一个长度为n的整数数列。

请你使用快速排序对这个数列按照从小到大进行排序。

并将排好序的数列按顺序输出。

**输入格式**

输入共两行，第一行包含整数 n。

第二行包含 n 个整数（所有整数均在1~10^9范围内），表示整个数列。

**输出格式**

输出共一行，包含 n 个整数，表示排好序的数列。

**数据范围**

**1≤n≤100000**

**输入样例：**

```text
5
3 1 2 4 5
```

**输出样例：**

```text
1 2 3 4 5
```
## 解题思路

**1、确定分界点**

**2、递归处理左右两段区间**

**3、归并两个区间**


### 核心思想

归并与[快排](https://bestyuan.fun/algorithm/quicksort/)一样，核心思想还是`分治`。

## 解题步骤

### 1、确定分界点

```text
                      
├——————————-————————————┤
           n
           ↓       
├—————————-—┤———————————┤
          n/2
           ↓
├———-—┤—————┤—————┤—————┤
     n/4    
            ↓
           ...
            ↓
├—┤—┤-—┤—┤—┤— ··· -┤—┤—┤—┤—┤—┤—┤—┤
 1            n   
                       
```

归并分界点为 `n/2` 处，假设每次左右两端为`l`、`r`，那么分界点每次为`mid = (l + r ) / 2`。

所以当分到不能再分的时候，也就是 `n / 2^n = 1` 的时候，分区结束，所以分区的`时间复杂度为log(n)`，也就是说要分log(n)次！

因为每分区完一次要比较一遍，所以每次分区后时间复杂度为`n`（第一次为n * 1 = n,第二次为 n/2 * 2 = n ，第三次为 n/4 * 4 = n …… 第n次为 1 * n = n）

所以总的时间复杂度就为分区的次数*每次分区的比较次数，即 O(n*log(n)) = nlog(n)。

`快排在理想状态下(分界点为n/2)`时间复杂度和归并一样都是O(nlogn)。

### 2、递归处理左右两个区间

这里和之前的快排思路类似，也是使用了双指针，但是需要一个`临时数组`来存储两个左右区间数组合并后的结果。

如下图所示
```text
↓ i
├———-—————┤ 
l         mid

↓ j
├———-—————┤ 
mid+1     r

```
一个指针(i)从`l`开始，也就是左半边的左边，一直到`mid`；另一个指针(j)从`mid+1`开始，也就是中间往后一个位置，一直到`r`。

两个指针相互比较大小，小的那个指针自++，每经过一个数比较一次，然后把小的值放到另一个数组 temp [] 中。


### 3、归并（合二为一）

归并过程是整个归并算法中的重点，过程如下所示

```text
↓i
1 3 7 5 2 4

↓j
2 4 5 7 8 9
```
指针 i、j 进行第一次比较，i[0] < j[0] ，然后 i++，新的数组为 temp = [1] ，第一次比较后结果为：
```text
  ↓i
1 3 7 5 2 4
↓j
2 4 5 7 8 9
```
第二次比较，i[1] > j[0]，所以j++ ，temp = [1,2] ，一直到 i[3] = j[2]，此时指针位置应为下图所示：

```text
      ↓i
1 3 2 5 2 4
    ↓j
2 4 5 7 8 9
```
此时 temp = [1,2,3,2,4]，此时 i[3] = j[2] ，这时先放谁到 temp 中都是一样的的，我们不妨设 i[3] <= j[2] ，然后一直到比较到 i[5] < j[2]，此时指针位置如下图：

```text
          ↓i
1 3 2 5 2 4
    ↓j
2 4 5 7 8 9
```
此时 temp = [1,2,3,2,4,5,2,4]，i++后，i空了，此时直接将`j剩下的所有数添加到temp中`，即temp = [1,2,3,2,4,5,2,4,5,7,8,9]

此时 i、j 位置如图：
```text
            ↓i
1 3 2 5 2 4
            ↓j
2 4 5 7 8 9
```

到此，算是处理完毕。 

## 代码实现
```C++
#include <iostream>

using namespace std;

const int  N = 1000010;

int n;

int q[N] , temp[N];

void merge_sort(int q[], int l ,int r)    // 传进来数组q 、左边界l、右边界r
{
    if (l >= r) return;   //判断区间是否为空（只有一个数），若为空则不需要再分
    
    int mid = (l+r)/2;    // 取 n/2的位置
    
    merge_sort(q, l, mid),merge_sort(q, mid+1, r); //左右分别递归分区
    
    int k = 0 , i = l, j = mid+1;     //  指针i起始位置为l ,j起始位置为mid+1
    
    while (i <= mid && j<=r)        // 若i <= mid 且 j <= r ，进行比较，然后将小的放进temp中
        if (q[i] <= q[j])  temp[k++] = q[i++];     
        else temp[k++] = q[j++];
        
    while (i <= mid) temp[k++] = q[i++];  //当i 还有剩余，全部放入 temp
    while (j <= r) temp[k++] = q[j++];    //当j 还有剩余，全部放入 temp
    
    for (i = l, j = 0 ; i <= r; i++ , j ++) q[i] = temp[j];   //将temp中排好的数给q
}


int main()
{
    scanf("%d",&n);
    
    for (int i = 0; i < n;i ++) scanf("%d ", &q[i]); //依次输入n个数，用数组q接受
    
    merge_sort(q,0,n-1);
    
    for(int i = 0 ; i < n ; i++) printf("%d ",q[i]); //依次打印数组q
    
    return 0;
}
```
若有不好或出错的地方，还请大家不吝请教~ :bow:

> good good study , day day up !

## 版本控制
Version|Action|Time
:-:|:-:|:-:
1.0|first commit|2019-10-24

